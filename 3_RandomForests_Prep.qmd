---
title: "3 RF Prep"
execute: 
  freeze: auto
---




*Libraries*
```{r}
#| label: Libraries
#| message: false
#| warning: false
#| code-fold: true
#| output: false

rm(list = ls())                                                      
gc()                                                                                 

# Data tidying and acces
library(tidyverse, quietly = T)       # Easy to read syntax and data manipulation                   
library(RSQLite)                      # Access SQLite dbs   
library(magrittr)                     # Pipes and math functions    
# library(readxl)                     # Read xlsx 
# library(writexl)                    # write xlsx     
                                                   
# yaImpute and related                           
library(yaImpute)                     # RF imputation     
library(vegan)                        # Something to do the yaImpute 
library(randomForest)                 # RF package that yaImpute uses                                   
                                                     
# plots and tables                          
# library(esquisse)                     # Quick data visualization   
# library(knitr)                        # Better html tables
# library(DT)                           # Data tables for Java script tables in HTML
                                                   
# library(kableExtra)                   # Better html tables, change sizes        
# library(feather)                      # Faster data retrieval    

# Geography
# library(sf)                           # Simple Features/vector data
# library(terra)                        # Raster functions
# library(spatstat)                     # Spatial stats


library(tcltk)                        # Fix file paths

# No sci-notation. 
options(scipen = 999)
```

*Functions*
```{r}
#| code-fold: true
#| label: Functions

clean_mem <- function() {
  x <- ls(envir = .GlobalEnv)
  # ls()[!(ls() %in% keep)]
  rm(list = x[!(x %in% keep)], envir = .GlobalEnv)
  gc()
}

clean_na_cols <- function(df){
  df <- df[, colSums(is.na(df)) < nrow(df)]
}

# path <- r"(C:\RxFire\Regen\FVS\regen_080724_1644\regen_080724_1644.db)"
clean_paths <- function(path) {
  str_replace_all(path, "\\\\", "/")
}

db_list <- function(df, CN_col){
  name <- NULL
  name <- df |> select({{CN_col}})
  name <- name |> mutate(CN_col = str_c("'", {{CN_col}}, "'")) 
  name <- str_flatten_comma(name$CN_col)
  # name <- str_flatten_comma(name[, CN_col])
  name
}

nas_to_zeroes <- function(df){
  df <- df |> mutate_all(~replace(., is.na(.), 0))
  df
}

add_commas <- function(n) {
  t <- prettyNum(n, ",",scientific=FALSE)
  return(noquote(t))
}

keep <- c("keep", "clean_mem", "clean_na_cols", "clean_paths", "db_list", "nas_to_zeroes", "add_commas")
```


___


```{r}
#| include: false
#| eval: false


rstudioapi::getSourceEditorContext()$path %>% basename()
```


**Created on**
```{r}
#| echo: false

ymd_hms(file.info("./3_RandomForests_Prep.qmd")$ctime, tz = "America/Los_Angeles")
```

**Last updated on**
```{r}
#| echo: false

ymd_hms(file.info("./3_RandomForests_Prep.qmd")$atime, tz = "America/Los_Angeles")
```


___





# Imputation Prep

I am pulling in the code that I used to run RF last time as a starting point. 

### Import Data

*Start with the paths to the 2_FVS DB and Standlist*
```{r}
clean_mem()

# "C:/RxFire/Regen/FVS/regen_080724_1644/regen_080724_1644.db"
# "C:/RxFire/Regen/FVS/regen_091724_2118/regen_091724_2118.db"

regen_db_path <- clean_paths(r"(C:\RxFire\Regen\FVS\regen_091724_2118\regen_091724_2118.db)")
standlist <- clean_paths(r"(./data/train_and_test.csv)")
standlist <-  read_csv(standlist, col_types = "cnc") 
standlist |> glimpse()
```

*Get CC, BA, SDI, etc from 2_FVS_variables.db*
```{r}

stplt_cn <- db_list(standlist, StandID)
# Get CC, BA, SDI and TPA. 
con <- dbConnect(RSQLite::SQLite(), regen_db_path)

comp <- dbGetQuery(con, 
                   str_c("select CaseID, StandID, CC from FVS_Compute where StandID in (", 
                              stplt_cn, ")"))
summary <- dbGetQuery(con, 
                      str_c("select CaseID, StandID, Tpa, BA, SDI from FVS_Summary2",
                            " where Year = 2014 and StandID in (", 
                            stplt_cn, ")"))
dbDisconnect(con)

pred <- left_join(comp, summary, join_by(CaseID, StandID)) %>% relocate(CaseID, .after = SDI)
```

*Get FIA data from 1.5_Create DB*
```{r}
# connecting to the WA state FIA db
fia_db_path <- clean_paths(r"(./data/homemade_fvs_db_17sept24.db)")
con <- dbConnect(RSQLite::SQLite(), fia_db_path)

# collecting the trees
tree <- dbGetQuery(
  con, 
  str_c("select * from FVS_TREEINIT_PLOT where STANDPLOT_CN in (", 
        stplt_cn, ")"))

# collecting tne plots and subplots
plot <- dbGetQuery(
  con, 
  str_c("select * from FVS_PLOTINIT_PLOT where STANDPLOT_CN in (", 
        stplt_cn, ")"))

dbDisconnect(con)
```

*Subsetting the tree table for living trees*
```{r}
# findNA <- tree %>% select_if(~ is.numeric(.)) |> rowSums()
# findNA
# 
# lt_wide[23,]
# 
# 
# dead_trees <- tree |> filter(HISTORY != 1)
# tree <- tree |> filter(HISTORY == 1)
# dead_trees |> select(STANDPLOT_CN) |> nrow()
```
1.965 subplots have dead trees 


*Get FPAG from 1_Import and Clean Standlist*
```{r}
fpags <- read_csv("./data/1_Import_Clean2.csv", 
                      col_types = "ccc")

fpags <- left_join(standlist, fpags, join_by(StandID == STANDPLOT_CN))
# summary(fpags)
```

```{r}
t <- tree |> select(STAND_CN) |> unique()
nrow(t) %>% add_commas()
plt_cn <- db_list(t, STAND_CN)
```

- 3,754 PLT_CNs


*Get Species reference from WA_FIA.db*
```{r}
# Getting the Species reference information
con <- dbConnect(
  RSQLite::SQLite(), "C:\\RxFire\\Data\\_FIADB_WA.db"
  )

fix <- dbGetQuery(con, str_c("select PLT_CN, SUBP, TREE, STATUSCD from TREE where PLT_CN in (", 
                             plt_cn, ")")) |> unique()



# Pulling in the species reference table
plants_ref <- dbGetQuery(
  con, "select SPECIES_SYMBOL, SPCD, COMMON_NAME, W_SPGRPCD from REF_SPECIES"
  )
plant_gr_ref <- dbGetQuery(
  con, "select SPGRPCD, NAME from REF_SPECIES_GROUP"
  ) 
dbDisconnect(con)

# Cleaning Species reference up
plants_ref <- plants_ref |> rename(SPGRPCD = W_SPGRPCD, SYMBL = SPECIES_SYMBOL)
plants_ref <- left_join(plants_ref, plant_gr_ref, by = join_by(SPGRPCD))
plants <- plants_ref |> select(SYMBL, SPCD)
```


#### Fix Tree Hist

*Fixing the tree list*
```{r}
tcns <- tree |> select(STANDPLOT_CN, TREE)
fix <- fix |> mutate(STANDPLOT_CN = str_c(PLT_CN, "_", SUBP)) |> select(STANDPLOT_CN, TREE, STATUSCD) |> unique()
fix$TREE <- as.character(fix$TREE)
fix <- left_join(tcns, fix, join_by(STANDPLOT_CN, TREE))

ltrees <- tree |> filter(DBH > 0.1 | is.na(DBH))
seeds <- tree |> filter(DBH == 0.1)

fix <- left_join(ltrees, fix, join_by(STANDPLOT_CN, TREE))
fix <- fix |> mutate(
  HISTORY = ifelse(STATUSCD != 1, 8, 1)
)
# fix |> filter(HISTORY == 8)

trees_dead <- fix |> filter(HISTORY == 8) |> select(-STATUSCD)
trees_live <- fix |> filter(HISTORY == 1) |> select(-STATUSCD)
trees_live <- add_row(trees_live, seeds)
```

**There are still some issues with this. TREE_COUNT and DIA are not always filled in for dead species.**



```{r}
CNs_live <- trees_live |> select(STANDPLOT_CN) |> unique()
fpags <- left_join(CNs_live, fpags, join_by(STANDPLOT_CN == StandID))
plot <- left_join(CNs_live, plot, join_by(STANDPLOT_CN))
pred <- left_join(CNs_live, pred, join_by(STANDPLOT_CN == StandID))
standlist <- left_join(CNs_live, standlist, join_by(STANDPLOT_CN == StandID))
tree <- left_join(CNs_live, trees_live, join_by(STANDPLOT_CN))

keep <- append(keep, c("CNs_live", "fpags", "plants", "plants_ref", "plot", 
                       "pred", "standlist", "tree"))
clean_mem()
```

*Are there any plots that only have dead trees*
There were 157 subplots that only had dead trees. I removed them 


- 10,430 subplots left after removing empty subplots with only dead trees, 027 removed. 18 Sept.



### Seedling Density

*Getting the wider dataframe that shows subplots with seedling density by species.*
```{r}
# Separating the seedlings from the rest
seedling_densities <- tree |>  filter(DBH == 0.1) |> 
  group_by(STANDPLOT_CN, SPECIES) |> 
# Add up the TPA per species on each subplot. 
  summarise(
    TPA = sum(TREE_COUNT), 
    .groups = "drop")

seedling_densities |> head()
```

*Adding species symbol to seedlings*
```{r}
# Prepare to join
seedling_densities <- seedling_densities |> mutate(SPECIES = as.numeric(SPECIES))
# Join seedlings and species reference
seedling_densities <- left_join(seedling_densities, plants, join_by("SPECIES" == "SPCD"))
# Removing an extra col. 
seedling_densities <- seedling_densities |> select(-c(SPECIES))
```

*Widening the seedling counts*
```{r}
# Widening the data
seedling_wide <- seedling_densities |> pivot_wider(names_from = SYMBL, 
                 values_from = TPA,
                 values_fill = 0,
                 names_glue = "{SYMBL}_{'TD'}")

# Un-grouping to avoid future messages
seedling_wide <- seedling_wide |> ungroup()
seedling_densities <- seedling_densities |> ungroup()

# Ensuring there are no NAs introduced while widening
seedling_wide <- nas_to_zeroes(seedling_wide)

seedling_wide |> head()
```

- 3,387 subplots have regeneration with 5,156 individual records of species and TPA. There were no NAs in seedlings. 
- 5,558 of 8,656, but this time I am doing this with both the test and training set. 


```{r}
keep <- append(keep, "seedling_wide")
```





**Checking the data for empty subplots**

___

### Large Tree Density

This is only to find out where the data is corrupt. 

*Listing out all plots and plots with seedlings*
```{r}
# clearing out the objects
CNs <- NULL
CNs_wSeedlings <- NULL
# creating lists of subplots
CNs <- pred |> select(STANDPLOT_CN) |> unique()
CNs_wSeedlings <- seedling_wide |> select(STANDPLOT_CN)
```





```{r}
# Find plots without regen
CNs_noRegen <- anti_join(CNs, CNs_wSeedlings, by = "STANDPLOT_CN")

# Get treelist for plots without seedlings
tree_noRegen <- left_join(CNs_noRegen, tree, by = "STANDPLOT_CN")

lt_density <- tree_noRegen |> group_by(STANDPLOT_CN, SPECIES) |> 
  summarize(
    TPA = sum(TREE_COUNT),
    .groups = "drop"
    )

lt_density <- lt_density |> mutate(SPECIES = as.numeric(SPECIES))
lt_density <- left_join(lt_density, plants, join_by("SPECIES" == "SPCD"))
lt_density <- lt_density |> select(-c(SPECIES))

lt_wide <- lt_density |> pivot_wider(names_from = SYMBL, 
                 values_from = TPA,
                 values_fill = 0,
                 names_glue = "{SYMBL}_{'lTD'}")

# There were NAs introduced by widening the data. 
# lt_wide <- lt_wide |> nas_to_zeroes()


# plots_noRegen <- lt_wide |> filter(!is.na(lt_records) & !is.na(seedling_records))
nrow(CNs_noRegen)
```
- 2,828 plots without seedlings and 3,387 with. 
- 4872 without

```{r}
4872 + 5558
```

- 6,215 is the same number of subplots as have living trees. 
- 10430 ...

```{r}
lt_wide |> nrow()
lt_wide |> drop_na() |> nrow()
```

**ADD status Code filter to 1.5_db History mutation**

The Nas were from dead trees. 


```{r}
nrow(CNs_noRegen) + nrow(CNs_wSeedlings)
```





```{r}
keep
```


___


# Predictors

Here is what I need:


- BA/ac mature
- Aspect in Northing and Easting
- Slope
- Elevation
- Lat/long

Here is what I have:

- F.P.A.G.
- BA stand
- SDI
- CC

I also need ecoregion. I should have saved it in the previous pages. 

```{r}
pred <- pred |> select(-CaseID)

t <- fpags |> select(STANDPLOT_CN, FPAG)
preds <- left_join(pred, t, join_by(STANDPLOT_CN))

rm(pred, t)
keep <- append(keep, c("preds", "wa_fiadb")) |> unique()

preds |> names() |> noquote()
```

```{r}
wa_fiadb <- clean_paths(r"(C:\RxFire\Data\_FIADB_WA.db)")
con <- dbConnect(RSQLite::SQLite(), wa_fiadb)

aspect <- dbGetQuery(con, "select aspect, slope, plt_cn, subp from SUBPLOT")
elev <- dbGetQuery(con, "select lat, lon, elev, ecosubcd, cn from PLOT")

dbDisconnect(con)
```

```{r}
t <- elev |> 
  uncount(weights = 4, .id = "SUBP") |> 
  mutate(STANDPLOT_CN = str_c(CN, "_", SUBP)) |> 
  relocate(STANDPLOT_CN, .after = CN) |> 
  select(-SUBP) |> rename(STAND_CN = CN)

t <- left_join(preds, t, join_by(STANDPLOT_CN)) |> unique()
preds <- t |> mutate(
  EcoRegion = str_remove_all(
    str_sub(ECOSUBCD, 1, -2), 
    " ")) |> select(-ECOSUBCD) |> 
  relocate(STANDPLOT_CN, STAND_CN, .after = EcoRegion) |> rename(BAp = BA)

preds |> names() |> noquote()
preds |> nrow()
```


```{r}
aspect <- aspect |> mutate(
  STANDPLOT_CN = str_c(PLT_CN, "_", SUBP)
)

aspect <- left_join(CNs, aspect, join_by(STANDPLOT_CN)) |> select(STANDPLOT_CN, ASPECT, SLOPE)
preds <- left_join(preds, aspect, join_by(STANDPLOT_CN)) |> relocate(ASPECT, SLOPE, .after = ELEV) |> 
  relocate(Tpa, .after = EcoRegion)

preds |> names() |> noquote()
preds |> nrow()
```


## Northing and Easting

```{r}
preds <- preds |> mutate(
  Northing = round(cos(ASPECT * pi/180), 8), 
  Easting = round(sin(ASPECT * pi/180), 8)
    ) |> relocate(Northing, Easting, .after = ASPECT) 

glimpse(preds)
```


# BA by spp

```{r}
#| include: false

clean_mem()
```
**Set BA to above 5 in.**

- I remember talking about setting BA to above 5 inches in Missoula, but I do not remember if I should also add those 
that are less than 5 to the seedlings. It wouldn't do to delete them. 
- I also remember there being talk about the differences in species growth rates and if 5 was a good overall choice. 
- **I am not going to do it now.**


```{r}
trees_L <- tree |> filter(DBH > 0.1)

trees_L <- trees_L |> mutate(
  BAac = ((DBH^2) * .005454) * TREE_COUNT 
) |> relocate(BAac, .after = DBH)

trees_L |> head()

plants$SPCD <- as.character(plants$SPCD)
trees_L <- left_join(trees_L, plants, join_by(SPECIES == SPCD))
trees_L |> relocate(SYMBL, .after = SPECIES) |> select(-SPECIES) |> head()
```

```{r}
# trees_L |> group_by(STANDPLOT_CN) |> summarise(n = n())

trees_L <- trees_L |> mutate(
  size_class = ifelse(DBH >= 5, "M", "S"), 
  size_class = ifelse(DBH > 20, "L", size_class), 
  size_class = ifelse(DBH <= 20 & DBH >= 10, "ML", size_class), 
  size_class = factor(size_class, levels = c("L", "ML", "M", "S"))
)

ba_trees <- trees_L |> group_by(STANDPLOT_CN, SYMBL) |> 
  summarise(
    n = n(), 
    BA = sum(BAac),
    .groups = "drop"
    )

# ba_trees |> head()
hist(ba_trees$BA, breaks = 109)

```

**I am not sure if I should run this as BA per ac**

```{r}
trees_L <- trees_L
y <- preds |> select(STANDPLOT_CN, EcoRegion) 
trees_L <- left_join(trees_L, y, join_by(STANDPLOT_CN))

trees_L <- trees_L |> mutate(
  size_class = ifelse(DBH >= 5, "M", "S"), 
  size_class = ifelse(DBH > 20, "L", size_class), 
  size_class = ifelse(DBH <= 20 & DBH >= 10, "ML", size_class), 
  size_class = factor(size_class, levels = c("L", "ML", "M", "S"))
)

ba_trees <- trees_L |> group_by(STANDPLOT_CN, SYMBL, EcoRegion) |> 
  summarise(
    n = n(), 
    BA = sum(BAac),
    .groups = "drop"
    )

order <- ba_trees |> group_by(SYMBL) |> 
  summarise(sum = sum(BA)) |> 
  arrange(desc(sum))
order <- order$SYMBL

ba_trees <- ba_trees |> mutate(
  SYMBL = factor(SYMBL, levels = order))
  
ecos <- unique(ba_trees$EcoRegion)
for (i in 1:length(ecos)) {
  print(
  ba_trees |> filter(EcoRegion == ecos[i]) |> ggplot() + 
  aes(x = SYMBL, y = BA, fill = SYMBL) + 
  geom_col() + 
  scale_x_discrete(guide = guide_axis(angle = 90)) + 
  labs(title = ecos[i])
)
}
```




```{r}
n_distinct(trees_L$STANDPLOT_CN) %>% add_commas()
```



## BA wider

```{r}
ba_trees <- trees_L |> group_by(STANDPLOT_CN, SYMBL) |> 
  summarise(
    n = n(), 
    BA = sum(BAac),
    .groups = "drop"
    )

n_distinct(ba_trees$STANDPLOT_CN)

ba_wide <- ba_trees |> select(-n) |> pivot_wider(names_from = SYMBL, 
                 values_from = BA,
                 values_fill = 0,
                 names_glue = "{SYMBL}_{'BA'}") 
ba_wide %>% head()
```







```{r}
y <- preds |> select(STANDPLOT_CN, EcoRegion) 
ba_wide <- left_join(ba_wide, y, join_by(STANDPLOT_CN))
ba_wide <- ba_wide |> relocate(EcoRegion, .after = STANDPLOT_CN)

ba_wide |> head()
```

```{r}
ba_wide <- left_join(ba_wide, preds, join_by(STANDPLOT_CN, EcoRegion)) |> 
  relocate(STANDPLOT_CN, CC, SDI, FPAG, EcoRegion, LAT, LON, ELEV, ASPECT, Northing, Easting, SLOPE, BAp) |> 
  select(-c(Tpa, STAND_CN))

ba_wide |> head()
```


```{r}
ba_wide |> nrow()
```

This is good. 
All that is left, is to join the large trees and seedlings together. Then, clean up the zeroes. 
Afterwards, I can run RF. 





# Joining tables

**28 Sept**

- There are 10,105 CNs with trees greater than .1"
- There are 5,558 CNs with Seedlings. 
- There are 10,430 CNs with living trees. 

- 324 stands don't have large trees
- 4,872 don't have seedlings. 

- 5,233 CNs have both seedlings and larger trees. 
- 5,197 CNs lack either the 325 Large tree cns or the 4,872 seedling cns. 


```{r}
cns_lt <- ba_wide %>% select(STANDPLOT_CN)
cns_seed <- seedling_wide %>% select(STANDPLOT_CN)

cns_wSeeds_and_ltrees <- inner_join(cns_lt, cns_seed)

cns_wSeeds_and_ltrees %>% nrow()
```




*These join without issue*
```{r}
t <- left_join(cns_wSeeds_and_ltrees, ba_wide)

seedling_wide <- left_join(seedling_wide, preds, join_by(STANDPLOT_CN)) |> 
  relocate(STANDPLOT_CN, CC, SDI, FPAG, EcoRegion, LAT, LON, ELEV, ASPECT, Northing, Easting, SLOPE, BAp) |> 
  select(-c(Tpa, STAND_CN))

t <- left_join(t, seedling_wide)

t %>% select(LAT, LON, PIPO_BA, PIPO_TD, ABGR_BA, ABGR_TD) %>% summary()
```

*These do not join well*
```{r}
#| message: false

cns_woSeeds_or_ltrees <- anti_join(CNs_live, cns_wSeeds_and_ltrees)

t <- left_join(cns_woSeeds_or_ltrees, ba_wide)

# seedling_wide <- left_join(seedling_wide, preds, join_by(STANDPLOT_CN)) |> 
#   relocate(STANDPLOT_CN, CC, SDI, FPAG, EcoRegion, LAT, LON, ELEV, ASPECT, Northing, Easting, SLOPE, BAp) |> 
#   select(-c(Tpa, STAND_CN))

t <- left_join(t, seedling_wide)

t %>% select(LAT, LON, PIPO_BA, PIPO_TD, ABGR_BA, ABGR_TD) %>% summary()
```


- 5,233 CNs have both seedlings and larger trees. 
- 5,197 CNs lack either the 325 Large tree cns or the 4,872


### Another approach

```{r}
#| message: false
#| warning: false

imp_data <- left_join(preds, ba_wide)

imp_data <- left_join(imp_data, seedling_wide)
imp_data %>% select(PIPO_BA) %>% summary()
imp_data %>% select(PIPO_TD) %>% summary()
imp_data %>% select(LAT, LON) %>% summary()


```
**That seems to have done it. I think that these are now joined properly.**



```{r}
imp_data <- imp_data %>% nas_to_zeroes()
```








```{r}
#| include: false

keep <- append(keep, c("ba_wide", "imp_data")) %>% unique()
clean_mem()
```





**ID and Predictors**
```{r}
imp_data <- imp_data %>% relocate(STANDPLOT_CN, STAND_CN)
imp_data <- imp_data %>% select(-c(Tpa, ASPECT))

pred_cols <- imp_data %>% select(!contains("BA")) %>% select(!contains("TD")) %>% names()

imp_data %>% select(all_of(pred_cols), contains("BA")) |> names() |> noquote()
```
**Response**
```{r}
imp_data %>% select(all_of(pred_cols), contains("TD")) |> names() |> noquote()
```


As far as getting the major overstory species by most prodigious seedlings per ecoregion, then matching those species' 
overstory BAs to them, I have the code to find the seedlings in Regen_notes:imp by FPAG. 
That is how I did this last time with diameter. I will continue with that in the next document as I think 
it is best done in the imputation loop. At least, I think doing it there will allow for more flexibility should the 
setup change. 


# Last Clean

```{r}
standlist <- standlist %>% mutate(TRAIN = ifelse(TRAIN == "train", T, F))

db_path <- "c:/RxFire/Regen/Regeneration_2_16Sept24/data/homemade_fvs_db_17sept24.db"
```



## Add Plants

```{r}
con <- dbConnect(
  RSQLite::SQLite(), "C:\\RxFire\\Data\\_FIADB_WA.db"
  )

# Pulling in the species reference table
plants_ref <- dbGetQuery(
  con, "select SPECIES_SYMBOL, SPCD, COMMON_NAME, W_SPGRPCD from REF_SPECIES"
  )
plant_gr_ref <- dbGetQuery(
  con, "select SPGRPCD, NAME from REF_SPECIES_GROUP"
  )
dbDisconnect(con)


# Cleaning Species reference up
plants_ref <- plants_ref |> rename(SPGRPCD = W_SPGRPCD, SYMBL = SPECIES_SYMBOL)
plants_ref <- left_join(plants_ref, plant_gr_ref, by = join_by(SPGRPCD)) |> rename(grp_name = NAME)

ba_spp <- imp_data %>% select(contains("BA")) %>% names() 
td_spp <- imp_data %>% select(contains("TD")) %>% names()

spp_list <- append(ba_spp, td_spp) %>% str_remove("_TD") %>% str_remove("_BA") %>% unique()
spp_list <- spp_list[spp_list != "BAp"] %>% sort()

plants_ref <- plants_ref |> select(SYMBL, SPCD, COMMON_NAME, SPGRPCD)

plants_ref <- plants_ref %>% filter(SYMBL %in% spp_list)
```


```{r}
#| eval: false

# con <- dbConnect(RSQLite::SQLite(), db_path)
# dbWriteTable(con, value = plants_ref, name = "plants_ref", overwrite=T)
# dbDisconnect(con)
```



## Add Econames

```{r}
eco_names <- tribble(~Eco3, ~ECO_NAME, ~eco_code, 
        "242A",  "Puget Tr.",    "PT", 
        "342I",  "Columbia B.",  "CB",
        "M242B", "W.Cascades",   "WC",
        "M242C", "E.Cascades",   "EC",
        "M242D", "N.Cascades",   "NC",
        "M333A", "Ok. High",      "OH")
```


```{r}
#| eval: false

# con <- dbConnect(RSQLite::SQLite(), db_path)
# dbWriteTable(con, value = eco_names, name = "eco_names", overwrite=T)
# dbDisconnect(con)
```



## Max_spp



```{r}
# Function for finding the nth most prevalent species by TD.
## Where b is the sorted list of all species by TD. 
n_largest <- function(x = b, n) {
  
  # In descending order, prevelance
  x1 <- sort(x, decreasing = TRUE)
  # Select the nth most prevelant. 
  x1[n]
}

y_resp <- imp_data %>% select(STANDPLOT_CN, EcoRegion, contains("TD"))
x_pred <- imp_data %>% select(!contains("TD"))

y <- y_resp |> select(-STANDPLOT_CN, -EcoRegion)
b <- names(y)

# For the i through nth most trees in each subplot
for (i in 1:3) {
    # set the new column name to largest_n
    c_value <- str_c("largest_", i)
    
    # For each subplot the largest_n is the nth place in a descending list by TD unless all are zero. 
    y <- y %>%
      rowwise() %>%
      mutate(!!c_value := n_largest(c_across(all_of(b)), i)) |>
      ungroup()
}



# The name of the species with the largest TD is the column name where the TD matches the largest_n
y$max_spp1 <- sapply(1:nrow(y), function(x) colnames(y)[which(y[x, b] == y$largest_1[x])][1])
y$max_spp2 <- sapply(1:nrow(y), function(x) colnames(y)[which(y[x, b] == y$largest_2[x])][1])
# The largest is always the largest or zero, but the second sometimes matches the first where either are zero or equal. 
# The alternate second and third replace the incorrect species names with the second name in the list.
# So, where spp1 and spp2 are both 75, spp1 is the first name in the list, and spp2 is the second name in the list. 
y$alt_spp2 <- sapply(1:nrow(y), function(x) colnames(y)[which(y[x, b] == y$largest_2[x])][2])
y$max_spp3 <- sapply(1:nrow(y), function(x) colnames(y)[which(y[x, b] == y$largest_3[x])][1])
y$alt_spp3 <- sapply(1:nrow(y), function(x) colnames(y)[which(y[x, b] == y$largest_3[x])][2])


# Replace the species names where they are equal with the alternates
y <- y |> mutate(
  max_spp2 = if_else(largest_1 == largest_2, alt_spp2, max_spp2),
  max_spp3 = if_else(largest_2 == largest_3, alt_spp3, max_spp3)
  ) |> select(-c(alt_spp2, alt_spp3))#, alt_spp3

# Set the species names to zero if there were no trees counted for that nth largest. 
yfull <- y |> mutate(
  max_spp1 = ifelse(largest_1 == 0, "zero", max_spp1),
  max_spp2 = ifelse(largest_2 == 0, "zero", max_spp2),
  max_spp3 = ifelse(largest_3 == 0, "zero", max_spp3)
  )
# Replace the CNs
yfull$STANDPLOT_CN <- y_resp$STANDPLOT_CN

# Put it back in front
yfull <- yfull |> relocate(STANDPLOT_CN)

# Look at one full example
# yfull |> filter(STANDPLOT_CN == "22954484010497_4") 
# Look at some examples of the results. 
yfull[4:8, 36:ncol(yfull)]


yfull <- yfull |> mutate(
  total_TD = rowSums(yfull[grep("_TD", names(yfull))])
)

imp_data_fixed <- left_join(x_pred, yfull, join_by(STANDPLOT_CN))
train_v_test <- standlist %>% select(-INVYR)

imp_data_fixed <- left_join(train_v_test, imp_data_fixed, join_by(STANDPLOT_CN))
```


```{r}
#| eval: false

# con <- dbConnect(RSQLite::SQLite(), db_path)
# dbWriteTable(con, value = imp_data_fixed, name = "imp_data", overwrite=T)
# dbDisconnect(con)
```


## Add eco_code

```{r}
imp_data_fixed <- left_join(imp_data_fixed, eco_names, join_by(EcoRegion == Eco3)) %>% 
  relocate(TRAIN, EcoRegion, ECO_NAME, eco_code, .after = STAND_CN)
```


```{r}
#| eval: false

# con <- dbConnect(RSQLite::SQLite(), db_path)
# dbWriteTable(con, value = imp_data_fixed, name = "imp_data", overwrite=T)
# dbDisconnect(con)
```









# Some Pred Eval

```{r}
imp_data <- imp_data_fixed

keep <- append(keep, "pred_cols")

glimpse(imp_data[,pred_cols])
```
## Plots, CC & others

```{r}
#| layout-ncol: 3
#| code-fold: true

t <- imp_data |> select_if(is.numeric)
t <- t |> select(-c(LAT,LON))
# names(t)


for(i in names(t[,1:6])) {
  # print(mean(t[[i]]))
  hist(
    t[[i]], 
    main = i, 
    xlab = i)
} 
```

```{r}
names(t)
```

## Plots, Maj Species

```{r}
#| layout-ncol: 4
#| code-fold: true

ba_cols <- imp_data %>% select(contains("_BA")) %>% names()

for(i in names(t[,ba_cols])) {
  # print(mean(t[[i]]))
  hist(
    t[[i]], 
    main = str_c(i), 
    xlab = i)
  
  hist(
    log(t[[i]]), 
    main = str_c("log of ",i), 
    xlab = i)
} 
```




# Response Histos


The major and minor here may be messed up. I didn't sort it like I did BA. As above, all plots are the same for major 
and minor, but rare uses a different rule for bins. I couldn't use the Freedman-Diaconis method when there were so few
data. 

Also I should have done Sum of tpa here instead of histograms. 
Plus, It would be better to do this by Ecoregion, but that would be a lot of plots. 

## Plots, Maj Species

```{r}
#| layout-ncol: 4
#| code-fold: true

tds_cols <- imp_data %>% select(contains("_TD")) %>% names()

for(i in names(t[,tds_cols])) {
  # print(mean(t[[i]]))
  hist(
    t[[i]], 
    main = str_c(i), 
    xlab = i)
  
  hist(
    log(t[[i]]), 
    main = str_c("log of ",i), 
    xlab = i)
} 
```





# END